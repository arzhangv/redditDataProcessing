{
    "op": {
        "upvote_ratio": null,
        "selftext": "I have repeatedly gotten some malware that looks like base64-encoded material. Example: https://pastebin.com/EjTBj2Y7\n\nI'm stumped decoding these files.\n\nI've gotten a number of those. That's a typical one. It does look like base64 encoded material. The bytes in it correspond to 0-9, A-Z, a-z, + and /, which is pretty much generic base64 encoding. This particular example doesn't have '=' bytes to pad it out, but some of the files do. All of the files have newline (ASCII 0x10, \"linefeed\") line endings, with 76 bytes per line excluding the newline.\n\nThe files are downloaded via a fake WSO (web shell by oRb), URIs:\n/wordpress//wp-content/plugins/revslider/temp/update_extract/revslider/db.php\n/wordpress//wp-content/uploads/wpallimport/uploads/f2af55ff3d3404c81a296c997348e8d1/db.php\n/wordpress/wp-content/plugins/revslider/temp/update_extract/revslider/db.php\n    /wp-content/plugins/revslider/temp/update_extract/revslider/info.php\n    /wp-content/plugins/wp-db-ajax-made/wp-ajax.php\n    /wp-content/themes/sketch/404.php\n    /wordpress//wp-content/plugins/revslider/temp/update_extract/revslider/db.php\n    /wp-content/plugins/revslider/temp/update_extract/revslider/info.php\n\nReinforcing the WSO observation: 4 POST parameters named \"a\", \"p1\", \"pass\" and \"ajax\". The \"pass\" parameter has the value \"nhzgrf\", which is a pretty common WSO password. The \"a\" parameter of WSO is \"action\", which usually has values like \"FilesMan\", \"SecInfo\", \"Php\" or \"RC\". The latter two are favored by attackers, because any PHP source arriving in parameter \"p1\" gets eval'ed.\n\nFor all these puzzling files, the \"a\" parameter has value \"NxAcGg==\", which base64 decode's to some non-ASCII bytes:  0x37 0x10 0x1c 0x1a\n\nIt seems like the \"a\" parameter value should be a hint, but I can't get anything out of it.\n\nLinux `base64 -d` does decode it, for what that's worth, but after that, I'm stumped. The decoded material looks like binary. It isn't xor-encoded, as a hamming distance key size test doesn't show any significant differences for any potential key size from 2 to 29 bytes.\n\nIt doesn't uncompress with anything I've tried (bunzip2, gunzip, unxz, unrar, uncompress, PHP gzinflate()). In fact, all of those throw an error on it.\n\nAll the encoded bytes are between 0 - 127, which suggests some kind of ASCII tranposition, or a least limiting input and output byte values to 0 - 127. Unfortunately, the frequency distribution is nothing like that for English text or Php or Perl, at least for the PHP and Perl I've got at hand. So it's not a simple Ceasar or substitution cipher.\n\nKasiski examination (https://en.wikipedia.org/wiki/Kasiski_examination) gives me a key length of 4, 8, 16, 24, ...  which seems to indicate a key length of 8.\n\nFriedman's Test (https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher#Friedman_test) gives the same sort of answer as Kaisiski examination: high index of coincidence values for bins of byte values of 4, 8, 16, etc.\n\nI can't for the life of me get a 4- or 8-column Vigenere cipher or multi-tranposition cipher to work for it.  I can't find a version of WSO that base64-decodes the \"a\" POST parameter, although I do have a version that base64-decodes the \"p1\" parameter before function actionPhp() evals it.\n\nLet me know if I've missed something, or if you know how to decode this, or if I can put another sample or two on pastebin.",
        "title": "Encoded malware - what encoding?",
        "score": 23,
        "id": "8hiaz6",
        "commsNum": 20,
        "timeStamp": "2018/05/06-14:10:03",
        "author_name": "bediger4000",
        "is_self": true,
        "locked": false,
        "num_comments": 20,
        "over_18": false,
        "spoiler": false,
        "subreddit": "malware",
        "stickied": false,
        "url": "https://www.reddit.com/r/Malware/comments/8hiaz6/encoded_malware_what_encoding/"
    },
    "posts": {
        "dzq7lv9": {
            "comment": "Actually a lot of decent, business-grade AV will unpack malware. If the packer uses rudimentary encryption, it can be pretty efficient to decrypt and perform static analysis on (some malware variants even use AES but with a PBKDF derived key from a 3 char password it brute forces at runtime). \n\nI can imagine that multiple layers of encryption makes it too slow to decrypt with the AV engine for static analysis and most AV vendors have abysmal runtime analysis capabilities. This malware sample is obviously from someone who has spent a lot of time trying to evade decent AV engines.",
            "timeStamp": "2018/05/28-14:19:18",
            "id": "dzq7lv9",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dykly28",
            "score": 1,
            "stickied": false,
            "author_name": "TheSecurityBug"
        },
        "dz42wwn": {
            "comment": "I found a cache of WSO instances I hadn't examined before. I found the following decrypting code in [WSO 4.1.1 and 4.2.5](https://github.com/wso-shell/WSO):\n\n    function decrypt($str, $pwd)\n    {\n        $pwd = base64_encode($pwd);\n        $str = base64_decode($str);\n        $enc_chr = '';\n        $enc_str = '';\n        $i = 0;\n        while ($i &lt; strlen($str)) {\n            for ($j = 0; $j &lt; strlen($pwd); $j++) {\n                $enc_chr = chr(ord($str[$i]) ^ ord($pwd[$j]));\n                $enc_str .= $enc_chr;\n                $i++;\n                if ($i &gt;= strlen($str)) {\n                    break;\n                }\n            }\n        }\n        return base64_decode($enc_str);\n    }\n\nThe important thing to notice is that it base64 decodes after the XOR. A little bit of fooling around with [CyberChef](https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true\\)XOR(%7B'option':'Latin1','string':''%7D,'Standard',false\\)From_Base64('A-Za-z0-9%2B/%3D',true\\)) and I found the 8-character/byte key: `bWtmaWxl`\n\nWhoever downloaded these files used the same key on all of them. I found instances of \"mumblehard\" and some other things.",
            "timeStamp": "2018/05/16-20:40:59",
            "id": "dz42wwn",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyo7x12": {
            "comment": "If I had the WSO in question, I could figure it out, or at least get a lot closer to an answer.  I can't send you the WSO - I've scrounged through all the downloads I can find that might install themselves as one of the URIs I gave above, to no avail. All of the sketch/404.php files and the rev_slider plugins downloaded to my honeypot don't have WSO that decodes. Here's the closest I can give you:\n\nhttps://pastebin.com/uk9z9i4f\n\nThat's all the information I can record from inside PHP on any given download.",
            "timeStamp": "2018/05/08-17:24:45",
            "id": "dyo7x12",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyn7e7g",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyn7e7g": {
            "comment": "This just looks like the final payload. What we need to see is the WSO itself to RE the payload decoder. It's likely something funky and custom, just looking, it looks like character substituted PHP code, but it'll be impossible without the WSO sample. \n\nSend me the bit that looks like this: \nhttps://github.com/bediger4000/php-malware-analysis/blob/master/WSO-htaccess.php/5.149.250.194WiwcZx5iWn4GRcs3Srr7ygAAAAo.0.file",
            "timeStamp": "2018/05/08-08:06:14",
            "id": "dyn7e7g",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk2rox",
            "score": 1,
            "stickied": false,
            "author_name": "baordog"
        },
        "dylvfkh": {
            "comment": "You absolutely can perform cryptanalysis knowing only the block size, but you've already done that and exhausted all the obvious possibilities. So at this point it's pretty much a wild goose chase unless you have the source. There are so many possibilities that it's probably not worth the effort. It could be some dumb handcrafted thing, or AES.\n\nCould you maybe find the source code for the real shell? That may help.",
            "timeStamp": "2018/05/07-14:29:20",
            "id": "dylvfkh",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dykm2kz",
            "score": 1,
            "stickied": false,
            "author_name": "catcradle5"
        },
        "dylpr79": {
            "comment": "Yeah, exactly this, I use cyberchef for this kind of checks.",
            "timeStamp": "2018/05/07-13:00:40",
            "id": "dylpr79",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dylm46i",
            "score": 1,
            "stickied": false,
            "author_name": "realvient"
        },
        "dylm46i": {
            "comment": "By \"differential XOR\", do you mean something like the Python in this: https://github.com/gchq/CyberChef/issues/17  ?\n\nOr is there another definition? That's the only one I can find.\n\nWhat do you mean by input differential XOR with no key? XOR-ing the ciphertext with itself, but offset by a byte?\n\nnewtext[i] = ciphertext[i] ^ ciphertext[i+1] ?\n",
            "timeStamp": "2018/05/07-12:05:04",
            "id": "dylm46i",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyldcem",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyldcem": {
            "comment": "If I see that data is not completely random (like all values less than 128 in this case), I try some random 1 byte keys and see if data become even more clear. In this case I tried key like 0x50 or 0x70 and there was a lot of English characters so I thought it may be Base64 encrypted with 1 byte XOR. It may not be as well, I poked it a bit but didn't manage to get all bytes as characters, there always were some brackets or bytes &lt; 0x20.\n\nAlso a good thing to do is to try input differential XOR with no key, it may reveal some internal structure if input differential mode is indeed used.",
            "timeStamp": "2018/05/07-09:50:42",
            "id": "dyldcem",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk5ilw",
            "score": 1,
            "stickied": false,
            "author_name": "realvient"
        },
        "dykmok2": {
            "comment": "I don't know for sure, but I think it's to change checksums, like md5, or to mask \"signature\" text that the \"AV engines\" look for. I have no idea why you'd gzip-base64-encode/repeat 20 times. I've wondered if some of the \"PHP decoders\" on the web have a limit of 20 levels of eval-recursion, so they just encode 21 times.\n\nThe masking hypothesis doesn't entirely ring true: a lot of the \"encoded\" WSO instances have \"FilesMAn\" in cleartext, which is an obviouis signature for that entire family of web shells. Also, what about common, all-malware encodings, like FOPO? If anything it encoded by FOPO, it's malware, so just the FOPO presence is an indicator.\n\nAlso, a large percentage of the \"wrapping\" is `eval(base64_decode($c));` or something very close. Any time `eval()` and `base64_decode()` get composed should be an instant flag to an AV.\n\nAs far as AVs decrypting suspicious binaries, you might want to look at Tavis Ormandy's [Sophail](https://lock.cmpxchg8b.com/sophail.pdf) and [Sophail 2](https://lock.cmpxchg8b.com/sophailv2.pdf) documents. I haven't read them in a while, but I think they did do some kind of simulated execution of binaries, and unpacking/decompressing/decrypting pieces of a binary.",
            "timeStamp": "2018/05/06-22:25:47",
            "id": "dykmok2",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dykly28",
            "score": 5,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dykm2kz": {
            "comment": "If I had the PHP (or any source) of the encoder, I could work from there. I don't have it: I've got a WordPress honeypot that includes a fake WSO web shell. The stuff in my pastes got downloaded. All I've got is in the pastes and what I wrote in my question.\n\nYou can certainly work out an xor-encoding (with enough ciphertext) based on key length and what you think the cleartext is (english, PHP, etc). You can work out a transposition cipher the same sort of way. I appears that you could work out the \"differential xor\" with just 127 tries (no bytes above 127), but differential xor produces Friedman test key lengths unlike those from my samples.",
            "timeStamp": "2018/05/06-22:09:31",
            "id": "dykm2kz",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dykipk1",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dykly28": {
            "comment": "Can someone tell me what the point is in wrapping your stub in layers of encryption? Why not just use something secure like AES, I mean AV\u2019s don\u2019t spend their time trying to decrypt suspicious binary data, do they? They\u2019ll catch you on method calls after usually, invoking the stub or whatever",
            "timeStamp": "2018/05/06-22:06:14",
            "id": "dykly28",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": 4,
            "stickied": false,
            "author_name": "Manifest122"
        },
        "dykipk1": {
            "comment": "You need to upload the PHP code that's actually doing the decoding. base64 is just a simple way of sending binary data. The actual binary data could be almost anything. No point spending ages trying to work out what encryption algorithm it's using when you can reverse engineer the code in a few minutes. You know it may have a block size of 4/8/16/32, but that still doesn't help you much when you know neither the algorithm nor the key.",
            "timeStamp": "2018/05/06-20:47:20",
            "id": "dykipk1",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": 1,
            "stickied": false,
            "author_name": "catcradle5"
        },
        "dykbemr": {
            "comment": "\nGh\n",
            "timeStamp": "2018/05/06-18:25:49",
            "id": "dykbemr",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": -1,
            "stickied": false,
            "author_name": "heroin_and_stimpy"
        },
        "dyk5ilw": {
            "comment": "Odd question, how do you identify 1 byte xor encryptions? I come across them a lot, but I cant identify them at a glance\n\nEdit changed for to xor",
            "timeStamp": "2018/05/06-16:31:03",
            "id": "dyk5ilw",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk1o8t",
            "score": 2,
            "stickied": false,
            "author_name": "DeathByHugz"
        },
        "dyk3051": {
            "comment": "If I had the WSO in question, I would have looked at that to figure out the encoding. But I don't have it.  And I can't find any that match, particularly when dealing with the \"a\" POST parameter value.\n\nI'll try single byte xor.  I haven't tried that so far.",
            "timeStamp": "2018/05/06-15:40:32",
            "id": "dyk3051",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk1o8t",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyk2tib": {
            "comment": "I agree. There's usually layers, maybe as many as 20. I think the first layer is base64 encoding, I can't get the 2nd layer.",
            "timeStamp": "2018/05/06-15:36:57",
            "id": "dyk2tib",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk10hm",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyk2rox": {
            "comment": "The pastebin link is to a whole sample.\n\nHere's couple more examples:\n\nhttps://pastebin.com/HU8DM77h\n\nhttps://pastebin.com/8gB7My4u\n\nEach of the pastes is a whole file downloaded to a fake WSO at different times.\n",
            "timeStamp": "2018/05/06-15:35:58",
            "id": "dyk2rox",
            "is_submitter": true,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk08z1",
            "score": 1,
            "stickied": false,
            "author_name": "bediger4000"
        },
        "dyk1o8t": {
            "comment": "Looks like 1 byte XOR. Note that there is also differential XOR as seen in ZeuS. Maybe the encoded text is also Base64, it can explain that values look like ASCII and you don't get English language distribution.\n\nBesides, reverse-engineering the sample is much easier than guessing encoding scheme.",
            "timeStamp": "2018/05/06-15:14:40",
            "id": "dyk1o8t",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": 3,
            "stickied": false,
            "author_name": "realvient"
        },
        "dyk10hm": {
            "comment": "Seconded. A lot of the data that I see in base64 typically has more than 1 obfuscation technique on it to hide the data, not just B64. ",
            "timeStamp": "2018/05/06-15:02:16",
            "id": "dyk10hm",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyk08z1",
            "score": 1,
            "stickied": false,
            "author_name": "DeathByHugz"
        },
        "dyk08z1": {
            "comment": "You need to post the whole samples, the only way to reverse it is be looking at the decoder. Did you try bruteforcing xor keys? ",
            "timeStamp": "2018/05/06-14:48:34",
            "id": "dyk08z1",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t1_dyjybj3",
            "score": 1,
            "stickied": false,
            "author_name": "baordog"
        },
        "dyjybj3": {
            "comment": "I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit:\n\n- [/r/tha_pit] [Encoded malware - what encoding?](https://www.reddit.com/r/tha_pit/comments/8hib1n/encoded_malware_what_encoding/)\n\n&amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*",
            "timeStamp": "2018/05/06-14:13:30",
            "id": "dyjybj3",
            "is_submitter": false,
            "link_id": "t3_8hiaz6",
            "parent_id": "t3_8hiaz6",
            "score": 1,
            "stickied": false,
            "author_name": "TotesMessenger"
        }
    }
}